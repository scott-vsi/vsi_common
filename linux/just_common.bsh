#!/usr/bin/env false
#This file should be sourced, NOT run

#****d* just/JUST_VERSION
# NAME
#   JUST_VERSION - Version number of just
# DESCRIPTION
#   If the version number from the last time the just setup script was sourced
#   and just do not match, a warning message will appear
#***
_last_just_version=${JUST_VERSION-}
export JUST_VERSION=0.0.2
   #If last just version was set and different
if [ "${_last_just_version}" != "" ] && \
   [ "${_last_just_version}" != ${JUST_VERSION} ]; then
  echo "WARNING: The version of just (${JUST_VERSION}) appears to have changed"
  echo "since last time (${_last_just_version})"
  echo "You may want to source ${JUST_SETUP_SCRIPT-your setup script} again"
  echo
fi
unset _last_just_version

#****d* JUST_VERSION/JUST_SETUP_SCRIPT
# NAME
#   JUST_SETUP_SCRIPT - Name of the just setup script
# DESCRIPTION
#   When writing a setup script, JUST_SETUP_SCRIPT can optionally be set to the
#   name of the script that will be used in messages such as the version check
# EXAMPLE
#   Usually developers will source a simple script to setup just. This primarily
#   includes adding just to the path and setting up tab complete:
#
#     export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
#     source "$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)/external/vsi_common/env.bsh"
#
#   This might also include adding plugins for tab-complete
#
#     JUST_HELP_FILES=("${VSI_COMMON_DIR}"/linux/just_git_functions.bsh)
#
#   This is also a convenient place to slip in git hooks
#   
#     #Create post-checkout hook
#     _just_temp_filename="$(dirname "${BASH_SOURCE[0]}")/.git/hooks/post-checkout"
#     if [ ! -e "${_just_temp_filename}" ]; then
#       cat <<-EOF > "${_just_temp_filename}"
#         #!/usr/bin/env bash
#     
#         if [ "\$1" != "\$2" ]; then
#           echo
#           echo "Don't forget to update your environment with the command: just sync"
#         fi
#         EOF
#       chmod 755 "${_just_temp_filename}"
#     fi
#     
#     #Create post-merge hook
#     _just_temp_filename="$(dirname "${BASH_SOURCE[0]}")/.git/hooks/post-merge"
#     if [ ! -e "${_just_temp_filename}" ]; then
#       cat <<-EOF > "${_just_temp_filename}"
#         #!/usr/bin/env bash
#     
#         echo
#         echo "Don't forget to update your environment with the command: just sync"
#         EOF
#       chmod 755 "${_just_temp_filename}"
#     fi
#     unset _just_temp_filename
# AUTHOR
#   Andy Neff
#***

#****if* just/_just_find_justfile
# NAME
#   _just_find_justfile -- Find the Justfile
# DESCRIPTION
#   Searches for the Justfile to load. It starts by checking the current 
#   directory, and goes up. Just like git searches for a .git directory
# INPUTS
#   $1 - The name of the files being searched for, typically: Justfile
# RETURN VALUE
#   echoes out the filename if found, else nothing
# AUTHOR
#   Andy Neff
#***
_just_find_justfile()
{
  local just_tmp_last_node=
  local just_tmp_stat_command=
  #speed improvement: if it's right there, echo it out right away
  if [ -f "${1}" ]; then
    echo "${1}"
    return
  fi
  #else search for the file
  if [ "$(\uname)" == "Darwin" ]; then
    just_tmp_stat_command="stat -f %d:%i ."
  else
    just_tmp_stat_command="stat -c %d:%i ."
  fi
  \pushd . > /dev/null
  while [ "${just_tmp_last_node}" != "$(\eval ${just_tmp_stat_command})" ]; do
    if [ -f "${1}" ]; then
      \echo "$(\cd "$(\dirname "${1}")"; \pwd)/$(\basename "${1}")"
      break
    fi
    just_tmp_last_node=$(\eval ${just_tmp_stat_command})
    \cd ..
  done
  \popd > /dev/null
}

#****f* just/_just_commands_from_file
# NAME
#   _just_commands_from_file -- Parses Justfile for help comments on targets
# SYNOPSIS
#   Look for all case statements with a comment at the end. It will also parse
#   commented case statements that exist for the purpose of populating the help
# INPUTS
#   $1 - Filename of Justfile to be parsed
# SEE ALSO
#   JUST_HELP_SEPARATOR, just/help
# AUTHOR
#   Andy Neff
#***
function _just_commands_from_file()
{
           # Segment into "command JUST_HELP_SEPARATOR comment"
  \sed -nE 's|^ *#? *([ _0-9|a-z-]*)\) *# *(.*)|\1 '"${JUST_HELP_SEPARATOR}"' \2|
            # If there is a match, process it
            t process
            # Else do not even print it. This replaces a grep
            b noprint
            :process
            # Converts aaa|bbb|ccc @#@ blah to aaa @#@ blah\nbbb @#@ blah\n...
            s/\|(.*_.* '"${JUST_HELP_SEPARATOR}"' (.*))/ '"${JUST_HELP_SEPARATOR}"' \2'$'\\\n''\1/
            # Continue processing until no matches
            t process
            p
            :noprint' $1
}

#****f* just/_just_subcommands_from_array
# USAGE
#   IFS=$'\n'
#   parsed_help_a=($(_just_commands_from_file "${JUSTFILE}"))
#   _just_subcommands_from_array <<< "${parsed_help_a[*]}"
#***
function _just_subcommands_from_array()
{
  \sed -nE 's|^(_?[a-zA-Z0-9\-]+)_.*|\1|p'
}

#****f* just/_just_subtargets_from_array
# USAGE
#   IFS=$'\n'
#   parsed_help_a=($(_just_commands_from_file "${JUSTFILE}"))
# 
#   _just_subtargets_from_array ${TARGET} "${parsed_help_a[@]}"
# INPUTS
#   $1 - subcommand name
#   $2..N - help_lines
# RETURN VALUE
#   just_subtargets - Adds to array
#***
function _just_subtargets_from_array()
{
  local help_line
  local subcommand="${1}"
  shift 1

  for help_line in ${@+"${@}"}; do
    if [[ ${help_line} =~ ^${subcommand}_.* ]]; then
      help_line=${help_line%% *}
      just_subtargets+=(${help_line#*_})
    fi
  done
}

#****f* just/_just_parse_helps
# NAME
#   _just_parse_helps -- Parse help information out of Just files
# INPUT
#   array JUST_HELP_FILES - List of Just files, including plugins
# OUTPUT
#   parsed_help_a - Array of help lines: "target ${JUST_HELP_SEPARATOR} message"
# AUTHOR
#   Andy Neff
#***
function _just_parse_helps()
{
  local filename
  local IFS=$'\n'
  parsed_help_a=()

  for filename in ${JUST_HELP_FILES+"${JUST_HELP_FILES[@]}"}; do
    parsed_help_a+=($(_just_commands_from_file "${filename}"))
  done
}
