#!/usr/bin/env bash

source "$(dirname "${BASH_SOURCE[0]}")"/ask_question

#Requires ca-certificates wget

: ${PIP2=pip2}
: ${PIP3=pip3}

: ${VERBOSE=0}

if [ "${VERBOSE}" == "0" ]; then
  exec 3>/dev/null
else
  exec 3>&2
fi

#comma separated list of binary only packages
PIP_BINARY_ONLY="entrypoints,bash_kernel"

function get_packages()
{
  : ${PIP=${PIP2}}
  ${PIP} download -v -d /tmp "${@}" --no-binary :all: --only-binary "${PIP_BINARY_ONLY}" |
    tee >(cat 1>&2) |
    #this is a nasty tee hack due to https://github.com/docker/docker/issues/6880
    
    grep -E '^  Using version |^Collecting' |
    #Grep only the lines with useful information, pip 8.1.2 specific!

    sed -E -e 's|^Collecting ([^ =<>~!]+).*|\1|' | 
    #Remove all but the package name, including any "extra"s but not including version restraint

    sed $'$!N;s|\\\n  Using||;P;D' | 
    #Combine lines starting with Using

    awk '{print $1 "@" $3}'
    #Print out the package name from the first sed and the version number which 
    #comes after [Using] version
}

#I do NOT use the --pre option for any of the pip commands, so pre-releases are
#not considered. The easiest way to add a pre-release is to use the custom
#requirements file

function write_requirement()
{ #filename package_info(form of name@version)
  package_name=${2%%@*}
  version=${2#*@}
  if [ "${version}" == "" ]; then
    echo "${package_name}" >> "$1"
  else
    echo "${package_name}==${version}" >> "$1"
  fi
}

function update_requirements()
{ # input_requirements_file output_requirements_file [other args]
  local input=$1
  local output=$2
  shift 2
  echo "Checking ${input}"
  for package in $(get_packages -r "${input}" ${@+"${@}"}); do
    write_requirement "${output}" "${package}"
  done 2>&3
}

function update_main_requirements()
{
  if [ ! -f "$1" ]; then
    echo "Skipping $1, not found"
    return
  fi
  #Strip all the version numbers so that the latests will be found
  awk -F '[<=>]' '{print $1}' "$1" > "$1.new"
  mv "$1.new" "$1"

  : > "$1.new"

  update_requirements "$1" "$1.new" --no-deps

  #Can't use wc -l here cause its buggy with blank lines, counting "newlines" not lines
  if [ "$(grep -cv '^\s*$' "$1")" == \
       "$(grep -cv '^\s*$' "$1.new")" ]; then
    mv -f "$1.new" "$1"
  else
    echo "Something went wrong"
    exit 1
  fi
}

function update_derived_requirements()
{ # main_requirements.txt custom_requirements.txt derived_requirements.txt
  echo "#Autogenerated file. Please run just update-python-requirements to update" > "$3"

  if [ -f "$2" ]; then
    update_requirements "$2" "$3"
  fi
  if [ -f "$1" ]; then
    update_requirements "$1" "$3"
  fi
}

files2=(python2)
files3=(python3)

function update_python_requirements()
{
  local use_pip2=0
  local use_pip3=0

  local tmp=(${PIP2})
  if command -v "${tmp[0]}" &> /dev/null; then
    use_pip2=1
  fi
  tmp=(${PIP3})
  if command -v "${tmp[0]}" &> /dev/null; then
    use_pip3=1
  fi

  if (( ${use_pip2} )); then
    for f in ${files2+"${files2[@]}"}; do
      update_main_requirements "requirements_${f}.txt"
    done
  fi
  if (( ${use_pip3} )); then
    for f in ${files3+"${files3[@]}"}; do
      PIP=${PIP3} update_main_requirements "requirements_${f}.txt"
    done
  fi

  for f in ${files2+"${files2[@]}"} ${files3+"${files3[@]}"}; do
    if [ -f "requirements_${f}.txt" ]; then
      echo "### requirements_${f}.txt ###"
      cat "requirements_${f}.txt"
    fi
  done

  echo "(Hint: You can edit the files before saying yes)"
  ask_question "Do these requirements look ok?" requirements "y"
  if [ "${requirements}" == "0" ]; then
    exit 1
  fi

  if (( ${use_pip2} )); then
    for f in ${files2+"${files2[@]}"}; do
      PIP="${PIP2}" update_derived_requirements "requirements_${f}.txt" \
                                                "requirements_${f}_custom.txt" \
                                                "requirements_${f}_derived.txt"
    done
  fi

  if (( ${use_pip3} )); then
    for f in ${files2+"${files3[@]}"}; do
      PIP="${PIP3}" update_derived_requirements "requirements_${f}.txt" \
                                                "requirements_${f}_custom.txt" \
                                                "requirements_${f}_derived.txt"
    done
  fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  update_python_requirements
  exit $?
fi