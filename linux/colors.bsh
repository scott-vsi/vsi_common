#!/usr/bin/env false
#Source this script for colors

#****F* vsi/colors.bsh
# NAME
#   colors.bsh - Collection of named colors and color functions
# DESCRIPTION
#   By sourcing this file and running color_setup, all the basic colors and
#   styles are made available in a terminal. Additional functions such as FG and
#   BG give access to arbitrary colors by index. Some terminals support up to
#   256 colors, as number_colors indicates.
# SEE ALSO
#   colors.bsh/color_setup colors.bsh/FG colors.bsh/BG colors.bsh/number_colors
# BUGS
#   Having variables with color codes in them can make looking at "set",
#   "declare/typeset", or "bash -xv" very noisy, as colors aren't cleared from 
#   line to line in bash
# AUTHOR
#   Andy Neff
#*** 

#****f* colors.bsh/color_setup
# NAME
#   color_setup - Set up variables and functions for colors and styles
# DESCRIPTION
#   Sets the values for the 8 basic colors (BLACK, RED, GREEN, YELLOW, BLUE,
#   MAGENTA, CYAN, and WHITE), and styles (BOLD, DIM, ITALIC, UNDERLINE, BLINK,
#   OVERLINE, HIDDEN and STRIKETHROUGH) and RESET, RESET_<style name>. In 
#   addition, LIGHT_<color>, <color>_BG, LIGHT_<color>_BG, and <color> are all
#   set.
#   COLOR_NAMES is set to an array of 8 basic color names and the array COLORS
#   is set to the color codes for those 8 colors by default.
# EXAMPLE
#   color_setup
#   echo "This is ${RED}red text${RESET}."
# NOTES
#   This is automatically called by sourcing colors.bsh
# SEE ALSO
#   colors.bsh/FG colors.bsh/BG colors.bsh/number_colors
# AUTHOR
#   Andy Neff
#***
function color_setup()
{
  local color

  # The 8 Colors
  COLOR_NAMES=(BLACK RED GREEN YELLOW BLUE MAGENTA CYAN WHITE)
  COLORS=()
  BLACK=0
  RED=1
  GREEN=2
  YELLOW=3
  BLUE=4
  MAGENTA=5
  CYAN=6
  WHITE=7

  local _normal=30
  local _light=90
  local _bg=10
  local _reset=20

  RESET=$'\e[0m'
  NC=${RESET}
  BOLD=$'\e[1m'
  DIM=$'\e[2m'
  ITALIC=$'\e[3m'
  UNDERLINE=$'\e[4m'
  BLINK=$'\e[5m'
  OVERLINE=$'\e[6m'
  REVERSE=$'\e[7m'
  HIDDEN=$'\e[8m'
  STRIKEOUT=$'\e[9m'

  RESET_BOLD=$'\e[21m'
  RESET_DIM=$'\e[22m'
  RESET_ITALIC=$'\e[23m'
  RESET_UNDERLINE=$'\e[24m'
  RESET_BLINK=$'\e[25m'
  RESET_OVERLINE=$'\e[26m'
  RESET_REVERSE=$'\e[27m'
  RESET_HIDDEN=$'\e[28m'
  RESET_STRIKEOUT=$'\e[29m'

  for color in "${COLOR_NAMES[@]}"; do
    eval "LIGHT_${color}=$'\e[$((${_light}+${!color}))m'"
    eval "${color}_BG=$'\e[$((${_normal}+${_bg}+${!color}))m'"
    eval "LIGHT_${color}_BG=$'\e[$((${_bg}+${_light}+${!color}))m'"
    eval "${color}=$'\e[$((${_normal}+${!color}))m'"
    COLORS+=(${!color})
  done
}

#****f* color.bsh/get_color
# NAME
#   get_color - Retrieve a color from the color map
# DESCRIPTION
#   get_color acts as a circular dictionary of colors
# INPUTS
#   $1 - Key value
# OUTPUT
#   stdout - The printable color code
# EXAMPLE
#   color_setup
#   if (( $(number_colors) < 88 )); then
#     COLORS=($RED $GREEN $YELLOW $MAGENTA $CYAN $WHITE)
#   else
#     COLORS=($(FG {9..15} 19 28 38 48 68 94 126 244))
#   fi
#   get_color first; echo "huh?"
#   echo "This is the first${RESET} color"
#   get_color second
#   echo "This is the second${RESET} color"
#   get_color first
#   echo "This is still the same first color${RESET} color"
# NOTES
#   The act of calling get_color echoes out the color code. So just calling
#   get_color will change the terminal color. If this is not desired, redirect
#   stdout to /dev/null
#
#   get_color ness > /dev/null
#
#   The color database is stored in COLOR_DB_NAMES (keys) and COLOR_DB_COLORS 
#   (values) and pull from the color pool COLORS
# BUGS
#   The color database can't be updated when executed in a subshell. This only
#   matter the first time a key is used. For example:
#
#   COLORS=($(FG {9..15} 19 28 38 48 68 94 126 244))
#
#   echo "This will $(get_color something)not${RESET} work"
#   echo "This will $(get_color something2)not${RESET} work"
#   # The same color twice will appear twice
#
#   get_color something > /dev/null
#   get_color something2 > /dev/null
#   echo "This will $(get_color something)so${RESET} work"
#   echo "This will $(get_color something2)so${RESET} work"
# AUTHOR
#   Andy Neff
#***
declare -a COLOR_DB_NAMES=()
declare -a COLOR_DB_COLORS=()
_COLOR_INDEX=0

_COLOR_SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")"; pwd)

function get_color()
{ #1 - colored_name
  local color_index=$("${_COLOR_SCRIPT_DIR}/findin" $1 ${COLOR_DB_NAMES+"${COLOR_DB_NAMES[@]}"})
  local this_color

  if [ "${color_index}" == "-1" ]; then
    #Get a color from colors, uses color_index % total_number_of_COLORS
    this_color=${COLORS[$((${_COLOR_INDEX}%${#COLORS[@]}))]}
    _COLOR_INDEX=$((${_COLOR_INDEX}+1)) #increment counter
    #Store color in database
    COLOR_DB_NAMES+=("$1")
    COLOR_DB_COLORS+=("${this_color}")
  else
    this_color="${COLOR_DB_COLORS[${color_index}]}"
  fi
  echo -n "${this_color}"
}

#****f* colors.bsh/FG
# NAME
#   FG - Retrieve foreground color code by index number
# DESCRIPTION
#   88/256 color support
# INPUTS
#   $1[...] - 1 or more color numbers
# OUTPUT
#   stdout - The printable color code(s)
# AUTHOR
#   Andy Neff
#***
function FG()
{
  local c
  for c in "${@}"; do
    echo -n $'\e[38;5;'$c'm '
  done
  : ${RESET} #Helps with bash -xv
}

#****f* colors.bsh/BG
# NAME
#   BG - Retrieve background color code by index number
# DESCRIPTION
#   88/256 color support
# INPUTS
#   $1[...] - 1 or more color numbers
# OUTPUT
#   stdout - The printable color code(s)
# AUTHOR
#   Andy Neff
#***
function BG()
{
  local c
  for c in "${@}"; do
    echo -n $'\e[48;5;'$c'm '
  done
  : ${RESET} #Helps with bash -xv
}

#****f* colors.bsh/number_colors
# NAME
#   number_colors - Ask the terminal emulator how many colors it support
# OUTPUT
#   stdout - The number of supported colors. Typically 8, 15, 16, 52, 88, or 256
# AUTHOR
#   Andy Neff
#***
function number_colors()
{
  tput colors
}

#****f* colors.bsh/color_demo1
# NAME
#   color_demo1 - Print out matrix of 8 Basic colors and all styles
# SYNOPSIS
#   Useful for determining which features the terminal emulator supports
# AUTHOR
#   Andy Neff
#***
function color_demo1()
{
  local x
  local y

  echo "Your terminal appears to support $(number_colors) colors"

  echo "8 Foreground Colors"
  
  printf '%-16sNormal\tBold\tDim\tItalics\tUnderline\tBlink\tOverline\tReverse\tHidden\tStrikeout\n' Color

  for x in "${COLOR_NAMES[@]}"; do
    for y in ${x} LIGHT_${x} ${x}_BG LIGHT_${x}_BG; do
      printf %-16s ${y}
      printf "${!y}${x}${RESET}\t"
      printf "${!y}${BOLD}${x}${RESET}\t"
      printf "${!y}${DIM}${x}${RESET}\t"
      printf "${!y}${ITALICS}${x}${RESET}\t"
      printf "${!y}${UNDERLINE}${x}${RESET}\t\t"
      printf "${!y}${BLINK}${x}${RESET}\t"
      printf "${!y}${OVERLINE}${x}${RESET}\t\t"
      printf "${!y}${REVERSE}${x}${RESET}\t"
      printf "${!y}${HIDDEN}${x}${RESET}\t"
      printf "${!y}${STRIKEOUT}${x}${RESET}\n"
    done
  done
  echo ${RESET}
}

#****f* colors.bsh/color_demo2
# NAME
#   color_demo2 - Print out matrix of 256 foreground colors
# SYNOPSIS
#   Useful for determining which features the terminal emulator supports
# AUTHOR
#   Andy Neff
#***
function color_demo2()
{
  local x

  echo "Foreground colors"
  for x in {0..255}; do
    printf "$(FG $x)%-5d" $x
    if (( $x%8 == 7 )); then
      echo $RESET
    fi
  done
  echo $RESET
}

#****f* colors.bsh/color_demo3
# NAME
#   color_demo3 - Print out matrix of 256 background colors
# SYNOPSIS
#   Useful for determining which features the terminal emulator supports
# AUTHOR
#   Andy Neff
#***
function color_demo3()
{
  local x

  echo "Background colors"
  echo -n $WHITE
  for x in {0..255}; do
    printf "$(BG $x)%-5d" $x
    if (( $x%8 == 7 )); then
      echo $RESET
    fi
  done
  echo $RESET
}

color_setup